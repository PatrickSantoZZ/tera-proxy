// Toolbox compatibility wrapper - (!) This API is subject to breaking changes without warning (!)

const path = require('path'),
	ModWrapper = require('./wrapper')

// TODO: Rework this so it can be inherited
const UNLOADED_PROTO = (() => {
	const error = (obj, key) => { throw Error(`Attempting to access property "${key}" after being unloaded`) }
	return new Proxy(Object.create(null), { get: error, set: error })
})()

const kLog = Symbol('kLog'),
	kCheckLogAbuse = Symbol('kCheckLogAbuse'),
	kLogAbuse = Symbol('kLogAbuse'),
	kRemap = Symbol('kRemap'),
	kHookArgs = Symbol('kHookArgs')

class CompatWrapper extends ModWrapper {
	constructor(info, dispatch) {
		super(info, dispatch)

		// Flag so mods can optionally provide their own workarounds
		this.isProxyCompat = true

		// Save logger because the name conflicts with another function
		this[kLog] = this.log
		delete this.log

		// Dispatch overrides
		const dispatchOverride = {
			fromRaw: (...args) => this.parse(...args),
			toRaw: (...args) => this.serialize(...args)
		}

		// Self overrides
		Object.assign(this, {
			// Note: This breaks any future sandboxing and will need to be changed
			info: Object.assign({}, info._compatInfo, { path: info._path }),

			manager: new ModuleManager(this),
			dispatch: new Proxy(dispatch, { get: (obj, key) => dispatchOverride[key] || obj[key] })
		})

		Object.defineProperty(this, 'require', {
			enumerable: true,
			configurable: true,
			value: new Proxy(Object.create(null), {
				get: (obj, key) => {
					const mod = this.dispatch.load(key)
					if(!mod) throw Error(`Required mod not found: ${key}`)

					return mod.instance || !mod._instance ? mod.instance
						: !mod._instance.requireInterface ? Object.assign({}, mod._instance)
						: mod._instance.requireInterface(mod._instance.globalMod, mod._instance.clientMod, mod._instance.networkMod, this)
				},
				set() { throw TypeError('Cannot set property of require')}
			})
		})

		// Settings migration
		const settingsVersion = this.info.options.settingsVersion
		if(settingsVersion)
			try {
				if(this.settings._version !== settingsVersion) {
					this.settings = require(
						path.join(this.info.path, this.info.options.settingsMigrator || 'module_settings_migrator.js')
					)(this.settings._version || null, settingsVersion, this.settings)
					this.settings._version = settingsVersion
				}
			}
			catch(e) {
				console.log(`[compat] Error migrating settings for "${this.name}"`)
				console.log(e)
			}

		// Client interface
		this.clientInterface = new ClientInterface(this)

		// Hardcoded timers
		if(this.info.name !== 'tera-game-state')
			this.hook('S_RETURN_TO_LOBBY', 'raw', () => {
				for(let t of this._timers) this.clearTimeout(t)
			})
	}

	init(modConstructors) {
		if(typeof modConstructors === 'function') {
			// Legacy shims
			Object.assign(this, {
				rootFolder: this.info.path,
				options: this.info.options,
				niceName: this.info.options.niceName,
				isClassic: this.patchVersion < 28
			})

			// Workaround abuse
			if(this.info.servers && this.info.servers.some(s =>
				/^https:\/\/raw\.githubusercontent\.com\/tera-shiraneko\//i.test(s.toLowerCase())
			)) {
				this.proxyAuthor = 'caali'
				this[kLogAbuse] = true
			}

			this._instance = { networkMod: this.instance = new modConstructors(this) }
			return
		}

		this._instance = {}

		if(modConstructors.GlobalMod) this._instance.globalMod = new modConstructors.GlobalMod(this)
		if(modConstructors.ClientMod) this[kLog].warn('Mod is attempting to install a 32-bit GPK - some features may not work')
		if(modConstructors.NetworkMod) this._instance.networkMod = new modConstructors.NetworkMod(this)
		if(modConstructors.RequireInterface) this._instance.requireInterface = modConstructors.RequireInterface
	}

	// TODO: Rework this so it can be inherited
	destroy(multiPass) {
		try {
			if(multiPass !== 2) {
				// Flush any changed settings to disk
				this._settings.flush()

				// Clear all timers
				for(let t of this._timers) this.clearTimeout(t)

				// Call mod-defined destructors
				let didDestroy = false
				for(let name of ['globalMod', 'networkMod', 'clientMod'])
					if(this._instance[name]?.destructor) {
						this._instance[name].destructor()
						didDestroy = true
					}
				return didDestroy
			}
		}
		finally {
			// Attempt to dereference as much as possible, hopefully crashing any memory leaked functions
			if(multiPass !== 1) {
				const instanceUnloadedProto = (() => {
					const modName = this.name,
						error = (obj, key) => { throw Error(`Attempting to access property "${key}" of unloaded mod "${modName}"`) }
					return new Proxy(Object.create(null), { get: error, set: error })
				})()

				for(let name of ['globalMod', 'clientMod', 'networkMod'])
					if(this._instance[name])
						Object.setPrototypeOf(this._instance[name], instanceUnloadedProto)
				Object.setPrototypeOf(this, UNLOADED_PROTO)

				for(let obj of [...['globalMod', 'clientMod', 'networkMod'].map(name => this._instance[name]).filter(i => i), this]) {
					if(typeof obj === 'function') obj.prototype = undefined
					for(let key of Object.getOwnPropertyNames(obj)) try { delete obj[key] } catch(e) {}
					for(let key of Object.getOwnPropertySymbols(obj)) try { delete obj[key] } catch(e) {}
				}

				Object.freeze(this)
			}
		}
		return false
	}

	// Instances
	get globalMod() { return this._instance.globalMod }
	get networkMod() { return this._instance.networkMod }
	get clientMod() { return this._instance.clientMod }

	// Client interface
	get language() { return this.clientInterface.info.language }
	get publisher() { return this.clientInterface.info.publisher }
	get platform() { return this.clientInterface.info.platform }
	get environment() { return this.clientInterface.info.environment }

	// Hardcoded mods
	get command() { return this.require.command }
	get game() {
		try {
			return this.require['tera-game-state']
		}
		catch(e) {
			this[kLog].error('Please install tera-game-state:\n    https://github.com/tera-mods-forks/tera-game-state')
			throw e
		}
	}

	// Timers
	get activeTimeouts() { return new Set([...this._timers].filter(t => !t._repeat)) }
	get activeIntervals() { return new Set([...this._timers].filter(t => t._repeat)) }

	clearAllTimeouts() { for(let t of this._timers) if(!t._repeat) this.clearTimeout(t) }
	clearAllIntervals() { for(let t of this._timers) if(t._repeat) this.clearTimeout(t) }

	// Logging
	log(...msg) { msg = msg.join(' '); if(!this[kCheckLogAbuse](msg)) this[kLog].info(msg) }
	warn(...msg) { msg = msg.join(' '); if(!this[kCheckLogAbuse](msg)) this[kLog].warn(msg) }
	error(...msg) { msg = msg.join(' '); if(!this[kCheckLogAbuse](msg)) this[kLog].error(msg) }

	[kCheckLogAbuse](msg) {
		if(this[kLogAbuse]) return true
		if(msg.includes('trying to use this module on an unsupported')) return this[kLogAbuse] = true
		return false
	}

	// Hooks / send
	[kRemap](name) {
		if(name === 'TTB_S_LOAD_EP_PAGE') return 'SU_CHANGE_EP_PAGE'
		return name
	}

	[kHookArgs](args) {
		// Remap custom packet names to proxy equivalents
		args[0] = this[kRemap](args[0])

		// Emulate slow, cloned raw hooks - Needed for NGSP, etc.
		if(args[1] === 'raw') {
			const cbIdx = typeof args[2] === 'function' ? 2 : 3,
				cb = args[cbIdx]
			args[cbIdx] = function(code, data, fromServer) {
				return cb.call(this, code, Buffer.from(data), fromServer)
			}
		}
		// Emulate event hooks using fast non-cloned raw hooks
		else if(args[1] === 'event')
			args[1] = 'raw'

		return args
	}

	hook(...args) { return super.hook(...this[kHookArgs](args)) }
	hookOnce(...args) { return super.hookOnce(...this[kHookArgs](args)) }
	send(name, ...etc) { return super.send(this[kRemap](name), ...etc) }

	// Old-style functions
	tryHook(...args) { try { return this.hook(...args) } catch(e) { return null } }
	tryHookOnce(...args) { try { return this.hookOnce(...args) } catch(e) { return null } }
	trySend(...args) { try { return this.send(...args) } catch(e) { return false } }

	// Settings
	loadSettings() {}
	saveSettings() {}
}

class ClientInterface {
	constructor(mod) {
		this.mod = mod

		this.info = {
			language: 'eur',
			publisher: 'gf',
			platform: 'pc',
			environment: 'live',
			protocolVersion: mod.protocolVersion,
			majorPatchVersion: mod.majorPatchVersion,
			minorPatchVersion: mod.minorPatchVersion
		}
	}
}

class ModuleManager {
	constructor(mod) { this.mod = mod }

	get(name) { return this.mod.dispatch.loadedMods.get(name) }
	isLoaded(name) { return this.mod.isLoaded(name) }
	isInstalled(name) { return this.mod.isLoaded(name) }
}

module.exports = CompatWrapper