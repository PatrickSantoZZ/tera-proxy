/*	@@Mod API
	This API is exposed to mods as the first argument passed to their constructor. An example mod is as follows:
	```js
	module.exports = function HelloWorld(mod) {
	/	mod.log.info('Hello, world!')
	}
	```
*/

const logger = require('log'),
	path = require('path'),
	Settings = require('./settings'),
	Hotswap = require('./hotswap')

const UNLOADED_PROTO = (() => {
	const error = (obj, key) => { throw Error(`Attempting to access property "${key}" after being unloaded`) }
	return new Proxy(Object.create(null), { get: error, set: error })
})()

class ModWrapper {
	constructor(info, dispatch) {
		const log = logger(info.name)

		Object.assign(this, {
			/*	#info
				`<Object>` A parsed version of this mod's `mod.json`.
			*/
			info,
			dispatch,
			name: info.name,
			/*	#log
				`<Object>` This mod's logger.
			*/
			log
		})

		this._timers = new Set()
		this._settings = new Settings(path.join(dispatch.modManager.settingsDir, this.name + '.json'), this.name)
	}

	init(modConstructor, hotswapProxy) {
		if(this.info.reloadable) {
			if(hotswapProxy) {
				const instance = new modConstructor(this)

				if(typeof instance !== typeof hotswapProxy)
					throw TypeError(`Cannot hotswap to different type: ${typeof instance} (expected ${typeof hotswapProxy})`)

				this.instance = hotswapProxy
				this.instance.__target__ = instance
			}
			else this.instance = Hotswap(new modConstructor(this))
		}
		else this.instance = new modConstructor(this)
	}

	destroy(multiPass) {
		try {
			if(multiPass !== 2) {
				// Flush any changed settings to disk
				this._settings.flush()

				// Clear all timers
				for(let t of this._timers) this.clearTimeout(t)

				// Call mod-defined destructor
				if(this.instance.destructor) {
					this.instance.destructor()
					return true
				}
			}
		}
		finally {
			// Attempt to dereference as much as possible, hopefully crashing any memory leaked functions
			if(multiPass !== 1) {
				const instanceUnloadedProto = (() => {
					const modName = this.name,
						error = (obj, key) => { throw Error(`Attempting to access property "${key}" of unloaded mod "${modName}"`) }
					return new Proxy(Object.create(null), { get: error, set: error })
				})()

				Object.setPrototypeOf(this.instance, instanceUnloadedProto)
				Object.setPrototypeOf(this, UNLOADED_PROTO)

				for(let obj of [this.instance, this]) {
					if(typeof obj === 'function') obj.prototype = undefined
					for(let key of Object.getOwnPropertyNames(obj)) try { delete obj[key] } catch(e) {}
					for(let key of Object.getOwnPropertySymbols(obj)) try { delete obj[key] } catch(e) {}
				}

				Object.freeze(this)
			}
		}
		return false
	}

	/*	#require
		`<Object>` A Proxy object which returns the specified mod's current instance. Throws an error if the required mod is not installed.
	*/
	get require() { return this.dispatch.require }

	/*	@isLoaded: name
		Returns #true if the specified mod is installed, #false otherwise.
	*/
	// Note: Calls require to prevent race condition
	isLoaded(name) {
		try {
			this.dispatch.require[name]
			return true
		}
		catch(e) { return false }
	}

	reload(name) { return this.dispatch.reload(name) }

	/*	#settings
		`<Object>` A persistent storage object backed by JSON. Each mod has their own #settings.
	*/
	get settings() { return this._settings.root }
	set settings(obj) {
		this._settings.loadRoot(obj)
		this._settings.changed()
	}

	/*	@setTimeout: callback, milliseconds[, ...args]
		Equivalent to `globalThis.setTimeout`, but is canceled when the mod is unloaded.
	*/
	setTimeout(cb, ms, ...args) {
		const timers = this._timers,
			t = setTimeout(function () {
				timers.delete(t)
				cb(...args)
			}, Math.floor(ms))

		timers.add(t)
		return t
	}

	/*	@setInterval: callback, milliseconds[, ...args]
		Equivalent to `globalThis.setInterval`, but is canceled when the mod is unloaded.
	*/
	setInterval(cb, ms, ...args) {
		const t = setInterval(cb, Math.floor(ms), ...args)
		this._timers.add(t)
		return t
	}

	/*	@clearTimeout: timeout
		Clears timers set by @setTimeout or @setInterval.
	*/
	clearTimeout(t) {
		clearTimeout(t)
		this._timers.delete(t)
	}

	/*	@clearInterval: timeout
		Clears timers set by @setTimeout or @setInterval.
	*/

	/*	@hook: id, def[, options], callback
		* #id `<String>` Packet name | `<Number>` Packet code | `'*'` All packets
		* #def `<Number>` Version number | `<Object>` Compiled protocol definition | `'raw'` Raw data
		* #options `<Object>`
		* * #order `<Number>` Hook priority. Lower numbers receive callbacks first, while higher numbers receive them later.
		* * #filter `<Object>`
		* * * #$fake `<Boolean>` | #null (default: #false)
		* * * #$incoming `<Boolean>` | #null (default: #null)
		* * * #$modified `<Boolean>` | #null (default: #null)
		* * * #$silenced `<Boolean>` | #null (default: #false)
		* * #timeout `<Number>` Milliseconds to wait before unhooking. When timeout occurs, #callback is fired with a single #null argument.
		* #callback `<Function>` in normal mode:
		* * #event `<Object>` The parsed data object
		* * * #$fake `<Boolean>`
		* * * #$incoming `<Boolean>`
		* * * #$modified `<Boolean>`
		* * * #$silenced `<Boolean>`
		* * #fake `<Boolean>` **`Deprecated`**
		* #callback `<Function>` in raw mode:
		* * #code `<Number>`
		* * #data `<Buffer>`
		* * * #$fake `<Boolean>`
		* * * #$incoming `<Boolean>`
		* * * #$modified `<Boolean>`
		* * * #$silenced `<Boolean>`
		* * #incoming `<Boolean>` **`Deprecated`**
		* * #fake `<Boolean>` **`Deprecated`**
		* Returns: `<Object>` The hook reference. See @unhook.

		Hooks a packet.
	*/
	hook(...args) { return this.dispatch.hook(this.name, ...args) }

	/*	@hookOnce: name, version[, options], callback
		Hooks a single packet, unhooking on callback. See @hook for options.
	*/
	hookOnce(...args) {
		const cb = args.pop()
		if(typeof cb !== 'function') throw Error('last argument not a function')

		const dispatch = this.dispatch
		return this.hook(...args, function(...hookArgs) {
			dispatch.unhook(this)
			return cb.call(this, ...hookArgs)
		})
	}

	/*	@hookAsync: name, version[, options], callback
		Returns a Promise that resolves with #event or rejects if timed out. See @hook for options.
	*/
	hookAsync(...args) {
		return new Promise((resolve, reject) => {
			this.hookOnce(...args, event => {
				if(event) resolve(event)
				else reject(Error('Hook timed out'))
			})
		})
	}

	/*	@unhook: hook
		Unhooks a previously hooked packet. If #hook is invalid, then this method silently fails.
	*/
	unhook(...args) { return this.dispatch.unhook(...args) }


	/*	@send: id, def[, object]
		* Returns: `<Boolean>` Success

		Sends a packet, inferring direction from the packet's name. Fields not specified are set to default values.
	*/
	send(name, version, data) {
		if(typeof name !== 'string') throw TypeError('Raw send() is not supported')

		switch(name[0]) {
			case 'C':
				return this.dispatch.write(true, name, version, data)
			case 'I':
			case 'S':
				return this.dispatch.write(false, name, version, data)
			default:
				throw Error(`Unknown packet direction: ${name}`)
		}
	}

	/*	@toClient: id, def[, object] | data
		* Returns: `<Boolean>` Success

		Sends a packet to the client. Fields not specified are set to default values.
	*/
	toClient(...args) { return this.dispatch.write(false, ...args) }

	/*	@toServer: id, def[, object] | data
		* Returns: `<Boolean>` Success

		Sends a packet to the server. Fields not specified are set to default values.
	*/
	toServer(...args) { return this.dispatch.write(true, ...args) }

	compileProto(...args) { return this.dispatch.protocol.compileProto(...args) }
	getProto(...args) { return this.dispatch.protocol.getProto(...args) }
	parse(...args) { return this.dispatch.protocol.read(...args) }
	serialize(...args) { return this.dispatch.protocol.write(...args) }
	packetLength(...args) { return this.dispatch.protocol.length(...args) }

	parseSystemMessage(...args) { return this.dispatch.parseSystemMessage(...args) }
	buildSystemMessage(...args) { return this.dispatch.buildSystemMessage(...args) }

	get protocolVersion() { return this.dispatch.protocolVersion }
	get region() { return this.dispatch.region }

	/*	#patchVersion
		`<Number>` A getter which returns the game's version number (ie. 93.04).
	*/
	get patchVersion() { return this.dispatch.getPatchVersion() }
	get majorPatchVersion() { return this.dispatch.majorPatchVersion }
	get minorPatchVersion() { return this.dispatch.minorPatchVersion }
}

// Assign aliases
(function() {
	Object.assign(this, {
		clearInterval: this.clearTimeout
	})
}).call(ModWrapper.prototype)

module.exports = ModWrapper